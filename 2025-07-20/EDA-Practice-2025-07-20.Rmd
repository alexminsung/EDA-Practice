---
title: "EDA-Practice-2025-07-20"
author: "Minsung Kim"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---


```{r message = FALSE}
# Load applicable libraries
library(dplyr)
library(tidyr)
library(zoo)
library(lubridate)
library(xts)
library(dygraphs)

# Load data
df <- read.csv("concurrent account spending_redacted.csv")

```

### Data Cleaning

We will do the following to prepare the data for the time-series plot.

-   Combine the Debit and Credit into one column of 'Values' and remove the -/+ signs (using absolute value).

-   Instead of relying on `SAVING` category, we will create two separate graphs. First graph will illustrate daily spending broken down into `NEEDS`, `WANTS`, and `MOM` (last one standing for money sent to my mom).

Second graph will compare combined spending against `INCOME`. The reason I chose not to use the `SAVING` indicator is that it is unreliable. Unfortunately, I only recorded positive amounts saved for the given month without accounting for "negative" savings (when spending exceeded revenue) during data entry. Therefore, I will aim to create a new dedicated `SAVINGS` column that takes the difference between `SPENDING` and `INCOME` at any given time.

-   Combine all duplicate dates so each row represents a unique date and the **cumulative value** of the spending type.

-   Rearrange the data so that each column represents spending type (e.g., `NEEDS`, `WANTS`, `MOM`) for each date row instead of having multiple date rows for different spending types.

-   Populate missing values (depending on how `dygraphs` handles missing data).

-   Convert the data into time-series compatible (xts) format to handle `dygraphs`.

```{r}
# replace "" under category as "INCOME". This will come in handy later when we create another plot of overall spending vs income
df$Category[df$Category == ""] <- "INCOME"

# replace NA with 0
df <- df %>% mutate_at(vars(Debit, Credit), ~replace(., is.na(.), 0))

# combine the debit and credit columns into one column of absolute values called 'value'
df <- df %>% mutate(value = abs(Debit + Credit))

# obtain cumulative spending values for 3 relevant categories. Note that I haven't included 'SAVINGS' and 'INCOME' as I am only interested in spending patterns for the first graph

# create a new column called 'cum_sum' which takes the values from the `value` column and obtains a cumulative sum. Afterwards, select only the `last` date row if there are multiple identical date rows for a given spending type. All other identical date rows (for a given spending type) are removed since the last row shows the final cumulative value.
df_NEED <- df %>% filter(Category == "NEEDS") %>% mutate(cum_value = round(cumsum(value),2)) %>% group_by(Transaction.Date) %>% summarise_all(last)
df_WANT <- df %>% filter(Category == "WANTS") %>% mutate(cum_value = round(cumsum(value),2)) %>% group_by(Transaction.Date) %>% summarise_all(last)
df_MOM <- df %>% filter(Category == "MOM") %>% mutate(cum_value = round(cumsum(value),2)) %>% group_by(Transaction.Date) %>% summarise_all(last)
# create a separate df containing only `INCOME` data. Trim the columns so only cumulative income and Transaction date (used as keys for JOIN function later)
df_INCOME <- df %>% filter(Category == "INCOME") %>% mutate(cum_value = round(cumsum(value),2)) %>% group_by(Transaction.Date) %>% summarise_all(last) %>% select(Transaction.Date, cum_value)

# combine the three datasets using row bind and rearrange the trimmed dataset by ascending date order. Remove all redundant columns.
df_trimmed <- bind_rows(df_NEED, df_WANT, df_MOM) %>% select(Transaction.Date, Category, Cumulative.Value = cum_value) %>% arrange(Transaction.Date) 

# rearrange the data so that each spending type is given their own columns and only one row exists per date. 
df_trimmed <- df_trimmed %>% pivot_wider(names_from = Category, values_from = Cumulative.Value)


# replace first NA values for `MOM` and `WANTS` with a baseline 0. This is not necessary for 'NEEDS' column as it already starts from 4
df_trimmed$MOM[1] <- 0
df_trimmed$WANTS[1] <- 0

# replace all following NA values from each column with the previous non-NA observation using `na.locf` (last observation carried forward)
df_trimmed$MOM <- na.locf(df_trimmed$MOM)
df_trimmed$NEEDS <- na.locf(df_trimmed$NEEDS)
df_trimmed$WANTS <- na.locf(df_trimmed$WANTS)

# create a version of the trimmed data with overall spending and overall income
df_plot2 <- df_trimmed %>% mutate(SPENDING = MOM + NEEDS + WANTS) 
df_plot2 <- left_join(df_plot2, df_INCOME, by = join_by(Transaction.Date)) 
# rename cumulative Income to INCOME
df_plot2 <- df_plot2 %>% rename(INCOME = cum_value)

# repeat the same steps as above to apply a baseline income of 0 and replace all NA values with the previous non-NA observation
df_plot2$INCOME[1] <- 0
df_plot2$INCOME <- na.locf(df_plot2$INCOME)


# convert df into xts time-series format. The original `Transaction.Date` column is removed as xts function will automatically created a new date column using the date-converted `df_trimmed$Transaction.Date` following the order.by parameter.
time_series_df <- xts(df_trimmed[,-1], order.by = as_date(df_trimmed$Transaction.Date))
time_series_df_plot2 <- xts(df_plot2[,c(-1:-4)], order.by = as_date(df_plot2$Transaction.Date))
```

### Viz

```{r}
# plot interactive plot of spending from 2023 June to 2025 June.
dygraph(time_series_df, main = "Spending Trend from June 2023 to June 2025") %>% dyAxis("y", label = "Cumulative Spending (CAD)") %>% dyLegend(width = 475) %>% dyRangeSelector() %>% dyCSS("dygraph.css")
```

```{r}
# plot overall spending vs overall income
dygraph(time_series_df_plot2, main = "Overall Spending vs Income (2023-06 to 2025-06)") %>% dyAxis("y", label = "Cumulative Spending (CAD)") %>% dyLegend(show = "follow") %>% dyRangeSelector() %>% dyCSS("dygraph.css") %>% dySeries("INCOME", fillGraph = TRUE, color = "green") %>% dySeries("SPENDING", fillGraph = TRUE, color = "red") 

```

### Credit
https://rstudio.github.io/dygraphs/gallery-series-highlighting.html